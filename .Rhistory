n_periods = 1
periods <- calculate_params_period(n_periods)
df_optimal_combination_3 <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
df_gen_assigned <- calculate_gen_assigned(df_gen, as.numeric(df_optimal_combination))
sum(calculate_surplus(df_gen, df_cons, combination))
df_optimal_combination_3
optimum_combination
df_optimal_combination
df_optimal_combination_3
combination
sum(calculate_surplus(df_gen, df_cons, optimal_combination_GA))
optimal_combination_GA <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
sum(calculate_surplus(df_gen, df_cons, optimal_combination_GA))
df_gen_assigned_GA
optimal_combination_GA
sum(calculate_surplus(df_gen, df_cons, combination))
optimal_combination_GA
combination
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
optimum_combination
plot_assignation(df_gen, df_gen_assigned_GA)
df_gen_assigned_GA <- calculate_gen_assigned(df_gen, as.numeric(df_optimal_combination))
df_gen_assigned_GA <- calculate_gen_assigned(df_gen, as.numeric(df_optimal_combination_GA))
df_gen_assigned_GA
df_gen
as.numeric(df_optimal_combination_GA)
df_optimal_combination_GA
df_gen_assigned_GA <- calculate_gen_assigned(df_gen, as.numeric(optimal_combination_GA))
df_gen_assigned_GA
plot_assignation(df_gen, df_gen_assigned_GA)
optimal_combination_GA
combination = optimal_combination_GA
df_gen
df_cons
not_selected_cons = (combination == 0)
not_selected_cons
df_cons[, not_selected_cons] = 0
df_cons
df_gen_assigned <- calculate_gen_assigned(df_gen, combination)
df_gen_assigned
cons_total = rowSums(df_cons)
cons_total
df_gen
hourly_surplus = df_gen - cons_total
hourly_surplus
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
# Size of the proposed community
n_community = 2
df_gen = data.frame("gen_1" = df_day_1[, "gen_1"])
df_cons = df_day_1[, grep(pattern = "cons", x = colnames(df_day_1))]
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
combination = zeros(1, length(df_cons))
combination[coeffs$user] = coeffs$optimum_coefficients
gen_assigned <- calculate_gen_assigned(df_gen, combination)
sum(calculate_surplus(df_gen, df_cons, combination))
combination
# to do the calculation of daily repartition => n_periods = 1
n_periods = 1
periods <- calculate_params_period(n_periods)
optimal_combination_GA <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
df_gen_assigned_GA <- calculate_gen_assigned(df_gen, as.numeric(optimal_combination_GA))
sum(calculate_surplus(df_gen, df_cons, optimal_combination_GA))
sum(calculate_surplus(df_gen, df_cons, combination))
sum(calculate_surplus(df_gen, df_cons, optimal_combination_GA))
optimal_combination_GA
optimum_combination
coeffs
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
combination = zeros(1, length(df_cons))
combination[coeffs$user] = coeffs$optimum_coefficients
# Size of the proposed community
n_community = 2
df_gen = data.frame("gen_1" = df_day_1[, "gen_1"])
df_cons = df_day_1[, grep(pattern = "cons", x = colnames(df_day_1))]
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
combination = zeros(1, length(df_cons))
combination[coeffs$user] = coeffs$optimum_coefficients
gen_assigned <- calculate_gen_assigned(df_gen, combination)
sum(calculate_surplus(df_gen, df_cons, combination))
combination
# to do the calculation of daily repartition => n_periods = 1
n_periods = 1
periods <- calculate_params_period(n_periods)
optimal_combination_GA <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
df_gen_assigned_GA <- calculate_gen_assigned(df_gen, as.numeric(optimal_combination_GA))
df_gen_assigned_GA
sum(calculate_surplus(df_gen, df_cons, optimal_combination_GA))
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
optimum_combination
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
combination = zeros(1, length(df_cons))
combination[coeffs$user] = coeffs$optimum_coefficients
gen_assigned <- calculate_gen_assigned(df_gen, combination)
sum(calculate_surplus(df_gen, df_cons, combination))
optimum_combination
df_combinations <- as.data.frame(combinations(n = length(df_cons), r = n_community, c(1:length(df_cons))))
df_combinations$surplus = 0
combination = zeros(1, length(df_cons))
combination
for (i in 1:nrow(df_combinations)) {
set_users <- as.numeric(df_combinations[i, c(1:n_community)])
combination_users = combination
combination_users[set_users] = 1/n_community
hourly_surplus <- calculate_surplus(df_gen, df_cons, combination = combination_users)
total_surplus <- sum(hourly_surplus)
df_combinations$surplus[i] = total_surplus
}
df_combinations
df_combinations <- df_combinations[order(df_combinations$surplus, decreasing = T), ]
df_combinations
order(df_combinations$surplus, decreasing = T)
library("gtools")
df_combinations <- as.data.frame(combinations(n = length(df_cons), r = n_community, c(1:length(df_cons))))
df_combinations$surplus = 0
combination = zeros(1, length(df_cons))
for (i in 1:nrow(df_combinations)) {
set_users <- as.numeric(df_combinations[i, c(1:n_community)])
combination_users = combination
combination_users[set_users] = 1/n_community
hourly_surplus <- calculate_surplus(df_gen, df_cons, combination = combination_users)
total_surplus <- sum(hourly_surplus)
df_combinations$surplus[i] = total_surplus
}
df_combinations
df_combinations <- df_combinations[order(df_combinations$surplus, decreasing = F), ]
df_combinations
optimum_combination <- df_combinations[1, ]
df_combinations <- df_combinations[order(df_combinations$surplus, decreasing = T), ]
df_combinations
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
optimum_combination
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
optimum_combination
optimal_combination_GA <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
optimal_combination_GA
optimum_combination
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
coeffs
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
optimal_combination_GA <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
optimal_combination_GA
calculate_surplus(df_gen, df_cons, combination = c(0.66, 0,0,0.33))
sum(calculate_surplus(df_gen, df_cons, combination = c(0.66, 0,0,0.33)))
sum(calculate_surplus(df_gen, df_cons, combination = c(1, 0,0,1)))
sum(calculate_surplus(df_gen, df_cons, combination = c(0.5, 0,0,0.5)))
sum(calculate_surplus(df_gen, df_cons, combination = c(0.8, 0,0,0.2)))
sum(calculate_surplus(df_gen, df_cons, combination = c(0.6, 0,0,0.4)))
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
sum(calculate_surplus(df_gen, df_cons, combination = c(1, 0,0,1)))
sum(calculate_surplus(df_gen, df_cons, combination = c(0.5, 0,0,0.5)))
sum(calculate_surplus(df_gen, df_cons, combination = c(0.5, 0,0,2)))
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
optimal_combination_GA <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
optimal_combination_GA
for (j in 1:n_periods) {
init = periods$init[j]
end = periods$end[j]
df_gen_period = df_gen[init:end, ]
df_cons_period = df_cons[init:end, ]
if (sum(df_gen_period) > 0)  {
optim_results <- ga(type = "real-valued", fitness = fitness,
lower = array(0, dim = ncol(df_cons)), upper = array(1, dim = ncol(df_cons)),
n_community = n_community, df_gen = df_gen_period, df_cons = df_cons_period,
popSize = 100, maxiter = 1000, run = 100)
# the algorithm gives as a result all the local minimums.. some criateria to select one of these minms?
solution <- optim_results@solution[1, ]
optimal_combination <- calculate_combination_GA(solution, n_community)
} else{
optimal_combination = array(0, dim = ncol(df_cons))
}
df_optimal_combination <- rbind(df_optimal_combination, optimal_combination)
}
init = periods$init[j]
end = periods$end[j]
df_gen_period = df_gen[init:end, ]
df_cons_period = df_cons[init:end, ]
(sum(df_gen_period) > 0)
optim_results <- ga(type = "real-valued", fitness = fitness,
lower = array(0, dim = ncol(df_cons)), upper = array(1, dim = ncol(df_cons)),
n_community = n_community, df_gen = df_gen_period, df_cons = df_cons_period,
popSize = 100, maxiter = 1000, run = 100)
optim_results@solution[1, ]
optimal_combination <- calculate_combination_GA(solution, n_community)
optimal_combination
# Size of the proposed community
n_community = 3
df_gen = data.frame("gen_1" = df_day_1[, "gen_1"])
df_cons = df_day_1[, grep(pattern = "cons", x = colnames(df_day_1))]
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
optimal_combination_GA <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
combination = zeros(1, length(df_cons))
combination[coeffs$user] = coeffs$optimum_coefficients
gen_assigned <- calculate_gen_assigned(df_gen, combination)
sum(calculate_surplus(df_gen, df_cons, combination))
optimum_combination
# to do the calculation of daily repartition => n_periods = 1
n_periods = 1
periods <- calculate_params_period(n_periods)
optimal_combination_GA <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
optimal_combination_GA
coeffs
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
# Size of the proposed community
n_community = 3
df_gen = data.frame("gen_1" = df_day_1[, "gen_1"])
df_cons = df_day_1[, grep(pattern = "cons", x = colnames(df_day_1))]
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
combination = zeros(1, length(df_cons))
combination[coeffs$user] = coeffs$optimum_coefficients
gen_assigned <- calculate_gen_assigned(df_gen, combination)
sum(calculate_surplus(df_gen, df_cons, combination))
optimum_combination
coeffs
# to do the calculation of daily repartition => n_periods = 1
n_periods = 1
periods <- calculate_params_period(n_periods)
optimal_combination_GA <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
df_gen_assigned_GA <- calculate_gen_assigned(df_gen, as.numeric(optimal_combination_GA))
sum(calculate_surplus(df_gen, df_cons, optimal_combination_GA))
df_gen_assigned_GA
optimal_combination_GA
coeffs
df_gen_assigned_GA <- calculate_gen_assigned(df_gen, as.numeric(optimal_combination_GA))
sum(calculate_surplus(df_gen, df_cons, optimal_combination_GA))
sum(calculate_surplus(df_gen, df_cons, combination))
solution
optimal_combination_GA
df_combinations <- as.data.frame(combinations(n = length(df_cons), r = n_community, c(1:length(df_cons))))
df_combinations$surplus = 0
combination = zeros(1, length(df_cons))
for (i in 1:nrow(df_combinations)) {
set_users <- as.numeric(df_combinations[i, c(1:n_community)])
combination_users = combination
combination_users[set_users] = 1/n_community
hourly_surplus <- calculate_surplus(df_gen, df_cons, combination = combination_users)
total_surplus <- sum(hourly_surplus)
df_combinations$surplus[i] = total_surplus
}
df_combinations
df_combinations <- df_combinations[order(df_combinations$surplus, decreasing = F), ]
df_combinations
combinations(n = length(df_cons), r = n_community, c(1:length(df_cons)))
combinations(n = length(df_cons), r = n_community, c(1:length(df_cons)))
combinations(n = length(df_cons), r = n_community)
combinations(n = length(df_cons), r = n_community)
df_combinations <- as.data.frame(combinations(n = length(df_cons), r = n_community))
df_combinations
df_combinations <- as.data.frame(combinations(n = 75, r = n_community))
df_combinations
nrow(df_combinations)
p = initial_plot(df_day_1)
p
df_day_1$cons_1 = df_day_1$cons_1*10
df_day_1 = generate_fake_data_test1(df_gen_1, df_cons_1, df_cons_2, df_cons_3, df_cons_4)
df_day_1$cons_1 = df_day_1$cons_1*3
p = initial_plot(df_day_1)
p
df_day_1 = generate_fake_data_test1(df_gen_1, df_cons_1, df_cons_2, df_cons_3, df_cons_4)
p = initial_plot(df_day_1)
p
# Size of the proposed community
n_community = 3
df_gen = data.frame("gen_1" = df_day_1[, "gen_1"])
df_cons = df_day_1[, grep(pattern = "cons", x = colnames(df_day_1))]
df_day_1$cons_1 = df_day_1$cons_1*2
df_day_1$cons_4 = df_day_1$cons_1/0.5
p = initial_plot(df_day_1)
p
df_day_1 = generate_fake_data_test1(df_gen_1, df_cons_1, df_cons_2, df_cons_3, df_cons_4)
df_day_1$cons_1 = df_day_1$cons_1*2
df_day_1$cons_4 = df_day_1$cons_4/0.5
p = initial_plot(df_day_1)
p
df_day_1 = generate_fake_data_test1(df_gen_1, df_cons_1, df_cons_2, df_cons_3, df_cons_4)
df_day_1$cons_1 = df_day_1$cons_1*2
df_day_1$cons_4 = df_day_1$cons_4*0.1
p = initial_plot(df_day_1)
p
# Size of the proposed community
n_community = 3
df_gen = data.frame("gen_1" = df_day_1[, "gen_1"])
df_cons = df_day_1[, grep(pattern = "cons", x = colnames(df_day_1))]
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
combination = zeros(1, length(df_cons))
combination[coeffs$user] = coeffs$optimum_coefficients
gen_assigned <- calculate_gen_assigned(df_gen, combination)
sum(calculate_surplus(df_gen, df_cons, combination))
coeffs
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
combination = zeros(1, length(df_cons))
combination[coeffs$user] = coeffs$optimum_coefficients
df_day_1 = generate_fake_data_test1(df_gen_1, df_cons_1, df_cons_2, df_cons_3, df_cons_4)
df_day_1$cons_1 = df_day_1$cons_1*2
df_day_1$cons_4 = df_day_1$cons_4*0.1
p = initial_plot(df_day_1)
# Size of the proposed community
n_community = 3
df_gen = data.frame("gen_1" = df_day_1[, "gen_1"])
df_cons = df_day_1[, grep(pattern = "cons", x = colnames(df_day_1))]
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
coeffs
combination = zeros(1, length(df_cons))
combination[coeffs$user] = coeffs$optimum_coefficients
gen_assigned <- calculate_gen_assigned(df_gen, combination)
sum(calculate_surplus(df_gen, df_cons, combination))
# to do the calculation of daily repartition => n_periods = 1
n_periods = 1
periods <- calculate_params_period(n_periods)
optimal_combination_GA <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
df_gen_assigned_GA <- calculate_gen_assigned(df_gen, as.numeric(optimal_combination_GA))
sum(calculate_surplus(df_gen, df_cons, optimal_combination_GA))
optimal_combination_GA
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
# to do the calculation of daily repartition => n_periods = 1
n_periods = 1
periods <- calculate_params_period(n_periods)
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
periods <- calculate_params_period(n_periods)
optimal_combination_GA <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
optimal_combination_GA
# to do the calculation of daily repartition => n_periods = 1
n_periods = 1
periods <- calculate_params_period(n_periods)
optimal_combination_GA <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
optimal_combination_GA
# to do the calculation of daily repartition => n_periods = 1
n_periods = 1
periods <- calculate_params_period(n_periods)
optimal_combination_GA <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
optimal_combination_GA
df_gen
df_cons
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
optimum_combination
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
coeffs
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
coeffs
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
coeffs
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
optimum_combination
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
df_individual <- data.frame("user" = as.numeric(optimum_combination[,(1:n_community)]),
"surplus" = 0)
combination = zeros(1, length(df_cons))
combination
# Calculate stat_coeffs (VERSION 2)
for (i in 1:n_community) {
set_users <- as.numeric(optimum_combination[,(1:n_community)])
combination_users = combination
combination_users[set_users[i]] = 1
hourly_surplus <- calculate_surplus(df_gen, df_cons, combination = combination_users)
total_surplus <- sum(hourly_surplus)
df_individual$surplus[i] = total_surplus
}
df_individual$optimum_coefficients = 1 - (df_individual$surplus/sum(df_individual$surplus))
df_individual
sum(df_individual$surplus)
(df_individual$surplus/sum(df_individual$surplus))
df_individual$optimum_coefficients = (sum(df_individual$surplus) - df_individual$surplus)/sum(df_individual$surplus)
df_individual
df_individual$optimum_coefficients = df_individual$surplus/sum(df_individual$surplus)
df_individual$surplus/sum(df_individual$surplus)
sum(df_individual$surplus)/df_individual$surplus
df_individual$optimum_coefficients = sum(df_individual$surplus)/df_individual$surplus
df_individual$optimum_coefficients = df_individual$optimum_coefficients/sum(df_individual$optimum_coefficients)
df_individual$optimum_coefficients
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
coeffs
df_day_1$cons_1 = df_day_1$cons_1*10
df_day_1 = generate_fake_data_test1(df_gen_1, df_cons_1, df_cons_2, df_cons_3, df_cons_4)
df_day_1$cons_1 = df_day_1$cons_1*10
df_day_1$cons_4 = df_day_1$cons_4*0.1
p = initial_plot(df_day_1)
p
# Size of the proposed community
n_community = 3
df_gen = data.frame("gen_1" = df_day_1[, "gen_1"])
df_cons = df_day_1[, grep(pattern = "cons", x = colnames(df_day_1))]
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
combination = zeros(1, length(df_cons))
combination[coeffs$user] = coeffs$optimum_coefficients
gen_assigned <- calculate_gen_assigned(df_gen, combination)
sum(calculate_surplus(df_gen, df_cons, combination))
source('~/Documents/projects/EKATE/transactive_energy_EKATE/optimization_GA_2.R', echo=TRUE)
##########################################################################################################
# for a small example I can solve the minimization problem looking for the ANALYTICAL SOLUTION
optimum_combination <- analytical_solution(n_community, df_gen, df_cons)
optimum_combination
coeffs = calculate_coefficients(optimum_combination, n_community, df_gen, df_cons)
coeffs
# to do the calculation of daily repartition => n_periods = 1
n_periods = 1
periods <- calculate_params_period(n_periods)
optimal_combination_GA <- optimize_repartition_GA_real_valued(n_periods, periods, n_community, df_gen, df_cons)
optimal_combination_GA
combinations(56, 5)
library(ggplot2)
library(lubridate)
filename_consumption = "consumption_escuela.csv"
df_cons = read.csv(file = filename_consumption, header = TRUE)
colnames(df_cons) = c("time", "cons")
head(df_cons)
filename_generation = "generation_escuela.csv"
df_gen = read.csv(file = filename_generation, header = TRUE)
colnames(df_gen) = c("time", "gen")
head(df_gen)
df_escuela = merge(x = df_cons, y = df_gen, by = "time")
head(df_escuela)
# time_interval = 15 min
df_escuela$time = as.POSIXct(x = df_escuela$time/1000, origin = "1970-01-01", tz = "Europe/Madrid")
measuring_start_time = as.POSIXct(x = "2019-10-17 00:15:00", tz = "Europe/Madrid")
covid_start_time = as.POSIXct(x = "2020-02-01 00:15:00", tz = "Europe/Madrid")
# df safe covid and with measures
df_escuela = df_escuela[df_escuela$time < covid_start_time & df_escuela$time > measuring_start_time, ]
# filter negative values
df_escuela = df_escuela[df_escuela$cons > 0, ]
df_escuela$dif = ifelse((df_escuela$gen - df_escuela$cons) > 0,
df_escuela$gen - df_escuela$cons,
NA)
ggplot(df_escuela) +
geom_line(aes(x = time, y = dif)) +
labs(x = "Time", y = "Energy [kWh]", title = "Hitorical Time Series") +
theme(legend.title = element_blank())
df_surplus = df_escuela[!is.na(df_escuela$dif) & df_escuela$dif > 2, ]
hour_dif = hour(df_surplus$time)
ggplot() +
geom_histogram(aes(hour_dif))
dif = df_surplus$dif
ggplot() +
geom_histogram(aes(dif))
month_dif = month(df_escuela$time[!is.na(df_escuela$dif)])
ggplot() +
geom_histogram(aes(month_dif))
ggplot(df_escuela) +
geom_line(aes(x = time, y = cons, color = "Consumption")) +
geom_line(aes(x = time, y = gen, color = "Generation")) +
labs(x = "Time", y = "Energy [kWh]", title = "Hitorical Time Series") +
scale_color_manual(values = c("red", "green")) +
theme(legend.title = element_blank())
df_escuela$cons_PV =  ifelse(df_escuela$gen > df_escuela$cons, df_escuela$cons, df_escuela$gen)
ggplot(df_escuela) +
geom_line(aes(x = time, y = cons_PV, color = "Consumption")) +
geom_line(aes(x = time, y = gen, color = "Generation")) +
labs(x = "Time", y = "Energy [kWh]", title = "Hitorical Time Series") +
scale_color_manual(values = c("red", "green")) +
theme(legend.title = element_blank())
df_escuela$ratio =  ifelse(df_escuela$gen != 0, df_escuela$cons_PV/df_escuela$gen, NA)
ggplot(df_escuela) +
geom_histogram(aes(ratio))
