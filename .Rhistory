# just checking
# if (any(individual_investment_selected > individual_investment_max)){
#   print("fail")
# }
# pre_payback[i, combination_selected!=0] = calculate_payback(df_cons_selected, df_gen, individual_investment_selected, pre_optimum_coefficients[i,combination_selected!=0])
# TODO:
# for (d in day) {
#
# }
d = 0
sunny_hours = which(df_gen != 0)
df_gen_day = df_gen[sunny_hours + (d*24),]
df_cons_selected_day = df_cons_selected[sunny_hours + d*24,]
n_sunny_hours = length(sunny_hours)
optim_results <- ga(type = "real-valued", fitness = fitness_2_betas,
lower = array(0, dim = n_community*n_sunny_hours), upper = array(1, dim = n_community*n_sunny_hours),
df_gen_day = df_gen_day, df_cons_selected_day = df_cons_selected_day, combination = combination_selected,
individual_investment = individual_investment_selected,
popSize = 100, maxiter = 5, run = 5)
coefficients_optimum <- optim_results@solution[1, ]
coefficients_optimum = matrix(data = coefficients_optimum, nrow = n_sunny_hours, byrow = T)
coefficients_optimum = coefficients_optimum/rowSums(coefficients_optimum)
combination_optimum = matrix(1, nrow = nrow(coefficients_optimum)) %*% combination_selected
combination_optimum[combination_optimum!=0] = coefficients_optimum
new_optimum_coefficients[[i]] = coefficients_optimum
new_payback[i, combination_selected!=0] = calculate_payback_betas(df_cons_selected_day, df_gen_day, individual_investment_selected, matrix_coefficients = coefficients_optimum)
surplus = sum(calculate_surplus_hourly_individual_betas(coefficients_optimum, df_gen_day, df_cons_selected_day))
new_surplus[i] <- surplus
vector_i = c(vector_i, i)
j = j + 1
}
}
results = list(
# "pre_optimum_coefficients" = pre_optimum_coefficients,
"pre_surplus" = pre_surplus,
# "pre_payback" = pre_payback,
"new_optimum_coefficients" = new_optimum_coefficients,
"new_surplus" = new_surplus,
"new_payback" = new_payback,
"vector_i" = vector_i)
results$vector_i
results$pre_surplus
results$new_optimum_coefficients
results$new_payback
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
############################# import libraries #############################
library(lubridate)
library(ggplot2)
library(ggpubr)
library(reshape2)
library(GA)
library(parallel)
library(purrr)
source("functions.R")
############################# data reading #############################
filename_gen_1 = "data/202005081411_charts_compare.csv"
# cons_1 is too high
filename_cons_1 = "data/202005081413_charts_compare.csv"
filename_cons_2 = "data/202005081655_charts_compare.csv"
filename_cons_3 = "data/202005081656_charts_compare.csv"
filename_cons_4 = "data/202005081658_charts_compare.csv"
# new:
filename_cons_5 = "data/202103171643_charts_historic.csv"
# gen_5 is too low
filename_gen_5 = "data/202103171649_charts_historic.csv"
filename_cons_6 = "data/202103171657_charts_historic.csv"
# gen_7 is too low
filename_gen_7 = "data/202103171735_charts_historic_generation.csv"
filename_cons_7 = "data/202103171735_charts_historic_cons.csv"
filename_cons_8 = "data/202103171814_charts_historic.csv"
filename_cons_9 = "data/202103171831_charts_historic.csv"
filename_cons_10 = "data/202103171835_charts_historic.csv"
# gen_10 is too low
filename_gen_10 = "data/202103171838_charts_historic.csv"
filename_cons_11 = "data/202103171858_charts_historic.csv"
filename_cons_12 = "data/202103171905_charts_historic.csv"
filename_cons_13 = "data/202103181018_charts_historic.csv"
filename_cons_14 = "data/202103181023_charts_historic.csv"
filename_cons_15 = "data/202103181029_charts_historic.csv"
filename_cons_16 = "data/202103181032_charts_historic.csv"
filename_cons_17 = "data/202103181037_charts_historic.csv"
filename_cons_18 = "data/202103181040_charts_historic.csv"
filenames_list = list(filename_gen_1, filename_cons_2, filename_cons_3, filename_cons_4, filename_cons_5, filename_cons_6, filename_cons_7, filename_cons_8, filename_cons_9, filename_cons_11, filename_cons_12, filename_cons_13, filename_cons_14, filename_cons_15, filename_cons_16, filename_cons_17, filename_cons_18)
df = lapply(X = filenames_list, FUN = import_one_user)
df_month_1 = select_month(df, m=7)
df_month_1 = eliminate_outliers(df_month_1)
df_month_1 = reducing_consumption_fake(df_month_1)
p = plot_initial(df_month_1)
df_month_1 = df_month_1[1:24,]
df_gen = data.frame("gen_1" = df_month_1[, "gen_1"])
df_cons = df_month_1[, grep(pattern = "cons", x = colnames(df_month_1))]
# changing NAs to 0
df_gen[is.na(df_gen)] = 0
df_cons[is.na(df_cons)] = 0
# should always use summer months to calculate the community max
n_community_max = calculate_n_community_max(generation = df_gen$gen_1, df_cons, time = df_month_1$time)
# n_community_max = 6
global_investment = max(df[[1]]$energy, na.rm = T)*1100
#######################################################################################
# generating fake info here: (should ask Eloi for new data)
df_cons = cbind(df_cons, df_cons)
colnames(df_cons)[17:32] = paste0(rep("cons_", 16),17:32)
n_binary_rep = log(ncol(df_cons), base=2)
# TODO: should change this
individual_investment = sapply(df_cons, max, na.rm = TRUE)*1100
# checking:
# sum(sapply(df_cons, max, na.rm = TRUE)*1100) > global_investment
# TODO:
# why the first run has this error? is it still appearing?
# Error in gareal_lsSelection_Rcpp(object) :
#   Too few positive probabilities!
tic = Sys.time()
# TODO: change this
optimal_combination_using_2_GAs <- optimize_hourly_betas(n_community_max, n_binary_rep, df_gen, df_cons, global_investment, individual_investment)
toc = Sys.time()
toc-tic
plot_optimization1_vs_optimization2(optimal_combination_using_2_GAs)
best_combination = select_best_combinations(optimal_combination_using_2_GAs)
df_gen_assigned = calculate_gen_assigned(df_gen = df_gen, combination = best_combination$optimum_coefficients)
df_gen_assigned_selected = df_gen_assigned[,best_combination$optimum_coefficients != 0]
df_cons_selected = df_cons[,best_combination$optimum_coefficients != 0]
best_combination = select_best_combinations(optimal_combination_using_2_GAs)
optimal_combination_using_2_GAs$new_surplus
length(optimal_combination_using_2_GAs$new_surplus)
length(optimal_combination_using_2_GAs$vector_i)
length(optimal_combination_using_2_GAs$new_optimum_coefficients)
length(optimal_combination_using_2_GAs$new_optimum_coefficients)
length(optimal_combination_using_2_GAs$pre_surplus)
optimal_combination_using_2_GAs$new_surplus[5960:5970]
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
optimal_combination_using_2_GAs$new_surplus[length(optimal_combination_using_2_GAs$vector_i)]
optimal_combination_using_2_GAs$new_surplus[length(optimal_combination_using_2_GAs$vector_i)+1]
optimal_combination_using_2_GAs$new_surplus = optimal_combination_using_2_GAs$new_surplus[1:length(optimal_combination_using_2_GAs$vector_i)]
length(optimal_combination_using_2_GAs$new_surplus)
new_optimum_coefficients = optimal_combination_using_2_GAs$new_optimum_coefficients
new_surplus = optimal_combination_using_2_GAs$new_surplus
new_payback = optimal_combination_using_2_GAs$new_payback
index_order = order(new_surplus, decreasing = F)
optimum_coefficients = new_optimum_coefficients[index_order[1],]
surplus = new_surplus[index_order[1]]
payback = new_payback[index_order[1], ]
new_optimum_coefficients
index_order[1]
index_order
new_optimum_coefficients[index_order[1]]
index_order[1]
new_optimum_coefficients[[index_order[1]]]
new_optimum_coefficients[[40]]
optimum_coefficients = new_optimum_coefficients[[index_order[1]]]
surplus = new_surplus[index_order[1]]
payback = new_payback[index_order[1], ]
select_best_combinations_betas(optimal_combination_using_2_GAs)
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
select_best_combinations_betas(optimal_combination_using_2_GAs)
new_surplus[index_order]
best_combination = select_best_combinations_betas(optimal_combination_using_2_GAs)
best_combination
rowSums(best_combination$optimum_coefficients)
best_combination
df_gen_assigned = calculate_gen_assigned(df_gen = df_gen, combination = best_combination$optimum_coefficients)
df_gen_assigned
df_gen
best_combination$optimum_coefficients
df_gen_assigned = calculate_gen_assigned_betas(df_gen = df_gen, combination = best_combination$optimum_coefficients)
df_gen_assigned
df_gen_assigned = calculate_gen_assigned_betas(df_gen = df_gen, combination = best_combination$optimum_coefficients)
df_gen_day
sunny_hours = which(df_gen != 0)
df_gen_day = df_gen[sunny_hours + 24,]
df_cons_selected_day = df_cons_selected[sunny_hours + 24,]
df_gen_assigned = calculate_gen_assigned_betas(df_gen_day = df_gen_day, combination = best_combination$optimum_coefficients)
df_gen_assigned = calculate_gen_assigned_betas(df_gen_day = df_gen_day, matrix_coefficients = best_combination$optimum_coefficients)
df_gen_assigned
df_gen_day
sunny_hours = which(df_gen != 0)
sunny_hours
df_gen
df_gen_day = df_gen[sunny_hours + 24,]
df_gen_day
df_gen_day = df_gen[sunny_hours,]
df_gen_day
df_gen_assigned = calculate_gen_assigned_betas(df_gen_day = df_gen_day, matrix_coefficients = best_combination$optimum_coefficients)
df_gen_assigned
df_gen_assigned
df_gen_assigned_selected
df_cons_selected_day = df_cons_selected[sunny_hours,]
df_gen_assigned
df_cons_selected
df_cons_selected_day
df_cons_selected
best_combination$payback!=0
!is.na(best_combination$payback)
is.na(best_combination$payback)
df_cons[sunny_hours, !is.na(best_combination$payback)]
df_cons_selected_day = df_cons[sunny_hours, !is.na(best_combination$payback)]
df_cons_selected = df_cons_selected_day
df_cons_selected_day
df_cons_selected = df_cons_selected_day
df_cons_selected
df_solar_consumption = calculate_solar_consumption(df_gen_assigned, df_cons_selected)
df_solar_consumption
df_gen
time = df_month_1$time
hour(time)
hour(time)
df_gen
df_gen$hour = hour(time)
df_solar_consumption$hour = hour(time)
df_solar_consumption
df_gen$hour = sunny_hours
df_gen$hour = hour(time)
df_solar_consumption$hour = sunny_hours
df_gen_mean = aggregate(x = df_gen, by = list(df_gen$hour), FUN = mean)
df_gen_mean
df_solar_consumption_mean = aggregate(x = df_solar_consumption, by = list(df_solar_consumption$hour), FUN = mean)
df_solar_consumption_mean
df_plot_solar_consumption_mean <- melt(data = df_solar_consumption_mean[, -grep(pattern = "Group.1", x = colnames(df_solar_consumption_mean))], variable.name = "series", id.vars = "hour")
p <- ggplot() +
geom_line(aes(x = df_gen_mean[, "hour"], y = df_gen_mean[, "gen_1"])) +
geom_area(aes(x = df_plot_solar_consumption_mean[, "hour"], y = df_plot_solar_consumption_mean[, "value"], fill = df_plot_solar_consumption_mean[,"series"]), alpha = 0.5) +
labs(x = "Time [h]", y = "PV generation [kWh]", "title" = paste0("PV assignation for month ",m), fill = "User")
ggplot() +
geom_line(aes(x = df_gen_mean[, "hour"], y = df_gen_mean[, "gen_1"])) +
geom_area(aes(x = df_plot_solar_consumption_mean[, "hour"], y = df_plot_solar_consumption_mean[, "value"], fill = df_plot_solar_consumption_mean[,"series"]), alpha = 0.5)
plot_disaggregated_daily_mean_per_user(df_gen_assigned = df_gen_assigned_selected, df_cons_selected = df_cons_selected, time = df_month_1[, "time"])
df_gen_assigned_selected
df_gen_assigned
plot_disaggregated_daily_mean_per_user(df_gen_assigned = df_gen_assigned, df_cons_selected = df_cons_selected, time = df_month_1[, "time"])
plot_disaggregated_daily_mean_per_user(df_gen_assigned = df_gen_assigned, df_cons_selected = df_cons_selected, time = df_month_1[, "time"])
df_cons_selected
df_gen_assigned
df_month_1[, "time"]
# calculate solar consumption and surplus
solar_consumption = calculate_solar_consumption(df_gen_assigned, df_cons_selected)
solar_consumption
solar_surplus <- df_gen_assigned - df_cons_selected
solar_surplus[solar_surplus < 0] = 0
grid = df_cons_selected - df_gen_assigned
grid[grid < 0] = 0
# add hour column
solar_consumption$hour = hour(time)
solar_consumption$hour
hour(time)
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
solar_consumption$hour = sunny_hours
solar_surplus$hour = sunny_hours
grid$hour = sunny_hours
# aggregate
solar_consumption_mean = aggregate(x = solar_consumption, by = list(solar_consumption$hour), FUN = mean)
solar_surplus_mean = aggregate(x = solar_surplus, by = list(solar_surplus$hour), FUN = mean)
grid_mean = aggregate(x = grid, by = list(grid$hour), FUN = mean)
# to calculate the self consumption and surplus
df_cons_selected$hour = hour(time)
# to calculate the self consumption and surplus
df_cons_selected$hour = sunny_hours
df_cons_selected_mean = aggregate(x = df_cons_selected, by = list(df_cons_selected$hour), FUN = mean)
df_gen_assigned$hour = sunny_hours
df_gen_assigned_mean = aggregate(x = df_gen_assigned, by = list(df_gen_assigned$hour), FUN = mean)
daily_hour <- solar_surplus_mean$hour
plots_list = list()
1:(ncol(df_cons_selected)-1)
user =1
solar_consumption_mean_user <- solar_consumption_mean[, c(1+user)]
grid_mean_user <- grid_mean[, c(1+user)]
solar_surplus_mean_user <- solar_surplus_mean[, c(1+user)]
df_plot <- data.frame("hour" = daily_hour,
"Solar_surplus" = solar_surplus_mean_user,
"Solar_consumption" = solar_consumption_mean_user,
"Grid_consumption" = grid_mean_user
)
df_plot = melt(df_plot, id.vars = "hour")
# TODO: understand which of the 2 is the correct one
# self_consumption_percentage_mean_1 = mean( df_plot[grep(x = df_plot$variable, pattern = "solar_consumption"), "value"] / df_cons_selected_mean[, user+1])
self_consumption_percentage_mean = sum(df_plot[grep(x = df_plot$variable, pattern = "Solar_consumption"), "value"]) / sum(df_cons_selected_mean[, user+1])
surplus_percentage_mean = sum(df_plot[grep(x = df_plot$variable, pattern = "surplus"), "value"]) / sum(df_gen_assigned_mean[, user+1])
p <- ggplot() +
geom_line(aes(x = df_cons_selected_mean[, "hour"], y = df_cons_selected_mean[, user+1])) +
geom_area(aes(x = df_plot[, "hour"], y = df_plot[, "value"], fill = df_plot[,"variable"]), alpha = 0.5) +
grids() +
labs(x = "Time [h]", y = "Energy [kWh]", "title" = paste0("User ", user,": self consumption = ", round(self_consumption_percentage_mean, digits = 2), " & surplus = ", round(surplus_percentage_mean, digits = 2)), fill = "")
p
for (user in 1:(ncol(df_cons_selected)-1)) {
solar_consumption_mean_user <- solar_consumption_mean[, c(1+user)]
grid_mean_user <- grid_mean[, c(1+user)]
solar_surplus_mean_user <- solar_surplus_mean[, c(1+user)]
df_plot <- data.frame("hour" = daily_hour,
"Solar_surplus" = solar_surplus_mean_user,
"Solar_consumption" = solar_consumption_mean_user,
"Grid_consumption" = grid_mean_user
)
df_plot = melt(df_plot, id.vars = "hour")
# TODO: understand which of the 2 is the correct one
# self_consumption_percentage_mean_1 = mean( df_plot[grep(x = df_plot$variable, pattern = "solar_consumption"), "value"] / df_cons_selected_mean[, user+1])
self_consumption_percentage_mean = sum(df_plot[grep(x = df_plot$variable, pattern = "Solar_consumption"), "value"]) / sum(df_cons_selected_mean[, user+1])
surplus_percentage_mean = sum(df_plot[grep(x = df_plot$variable, pattern = "surplus"), "value"]) / sum(df_gen_assigned_mean[, user+1])
p <- ggplot() +
geom_line(aes(x = df_cons_selected_mean[, "hour"], y = df_cons_selected_mean[, user+1])) +
geom_area(aes(x = df_plot[, "hour"], y = df_plot[, "value"], fill = df_plot[,"variable"]), alpha = 0.5) +
grids() +
labs(x = "Time [h]", y = "Energy [kWh]", "title" = paste0("User ", user,": self consumption = ", round(self_consumption_percentage_mean, digits = 2), " & surplus = ", round(surplus_percentage_mean, digits = 2)), fill = "")
ggsave(filename = paste0("graphs/user_",user), plot = p, device = "pdf", width = 5, height = 3)
}
df_cons
df_cons_selected_day = df_cons[, !is.na(best_combination$payback)]
df_cons_selected_day
df_gen_assigned = calculate_gen_assigned_betas(df_gen_day = df_gen_day, matrix_coefficients = best_combination$optimum_coefficients)
df_cons_selected = df_cons[,best_combination$optimum_coefficients != 0]
df_cons_selected_day = df_cons[, !is.na(best_combination$payback)]
df_cons_selected_day
df_cons_selected = df_cons_selected_day
df_gen_assigned
# calculate solar consumption and surplus
solar_consumption = calculate_solar_consumption(df_gen_assigned, df_cons_selected)
df_gen_assigned
df_cons_selected
# calculate solar consumption and surplus
solar_consumption = calculate_solar_consumption(df_gen_assigned, df_cons_selected[sunny_hours,])
solar_consumption
solar_surplus <- df_gen_assigned - df_cons_selected[sunny_hours,]
solar_surplus[solar_surplus < 0] = 0
grid = df_cons_selected[sunny_hours,] - df_gen_assigned
grid[grid < 0] = 0
# add hour column
solar_consumption$hour = sunny_hours
solar_consumption
# add hour column
solar_consumption$hour = sunny_hours
solar_surplus$hour = sunny_hours
grid$hour = sunny_hours
# aggregate
solar_consumption_mean = aggregate(x = solar_consumption, by = list(solar_consumption$hour), FUN = mean)
solar_surplus_mean = aggregate(x = solar_surplus, by = list(solar_surplus$hour), FUN = mean)
grid_mean = aggregate(x = grid, by = list(grid$hour), FUN = mean)
df_cons_selected
time
# to calculate the self consumption and surplus
df_cons_selected$hour = hour(time)
df_cons_selected_mean = aggregate(x = df_cons_selected, by = list(df_cons_selected$hour), FUN = mean)
df_gen_assigned$hour = sunny_hours
df_gen_assigned_mean = aggregate(x = df_gen_assigned, by = list(df_gen_assigned$hour), FUN = mean)
daily_hour <- solar_surplus_mean$hour
plots_list = list()
for (user in 1:(ncol(df_cons_selected)-1)) {
solar_consumption_mean_user <- solar_consumption_mean[, c(1+user)]
grid_mean_user <- grid_mean[, c(1+user)]
solar_surplus_mean_user <- solar_surplus_mean[, c(1+user)]
df_plot <- data.frame("hour" = daily_hour,
"Solar_surplus" = solar_surplus_mean_user,
"Solar_consumption" = solar_consumption_mean_user,
"Grid_consumption" = grid_mean_user
)
df_plot = melt(df_plot, id.vars = "hour")
# TODO: understand which of the 2 is the correct one
# self_consumption_percentage_mean_1 = mean( df_plot[grep(x = df_plot$variable, pattern = "solar_consumption"), "value"] / df_cons_selected_mean[, user+1])
self_consumption_percentage_mean = sum(df_plot[grep(x = df_plot$variable, pattern = "Solar_consumption"), "value"]) / sum(df_cons_selected_mean[, user+1])
surplus_percentage_mean = sum(df_plot[grep(x = df_plot$variable, pattern = "surplus"), "value"]) / sum(df_gen_assigned_mean[, user+1])
p <- ggplot() +
geom_line(aes(x = df_cons_selected_mean[, "hour"], y = df_cons_selected_mean[, user+1])) +
geom_area(aes(x = df_plot[, "hour"], y = df_plot[, "value"], fill = df_plot[,"variable"]), alpha = 0.5) +
grids() +
labs(x = "Time [h]", y = "Energy [kWh]", "title" = paste0("User ", user,": self consumption = ", round(self_consumption_percentage_mean, digits = 2), " & surplus = ", round(surplus_percentage_mean, digits = 2)), fill = "")
ggsave(filename = paste0("graphs/user_",user), plot = p, device = "pdf", width = 5, height = 3)
}
df_gen
sunny_hours_index = which(df_gen != 0)
df_gen_day = df_gen[sunny_hours_index,]
df_cons_selected_day = df_cons[, !is.na(best_combination$payback)]
sunny_hours_index
sunny_hours_index
df_gen = data.frame("gen_1" = df_month_1[, "gen_1"])
df_cons = df_month_1[, grep(pattern = "cons", x = colnames(df_month_1))]
# changing NAs to 0
df_gen[is.na(df_gen)] = 0
df_cons[is.na(df_cons)] = 0
df_gen
sunny_hours_index = which(df_gen != 0)
df_gen_day = df_gen[sunny_hours_index,]
df_cons_selected_day = df_cons[, !is.na(best_combination$payback)]
df_cons
# generating fake info here: (should ask Eloi for new data)
df_cons = cbind(df_cons, df_cons)
colnames(df_cons)[17:32] = paste0(rep("cons_", 16),17:32)
df_cons_selected_day = df_cons[, !is.na(best_combination$payback)]
df_cons_selected_day
optimal_combination_using_2_GAs$pre_surplus
save.image("~/Documents/projects/EKATE/transactive_energy_EKATE/results_optimization.RData")
df_gen_day
df_gen
############################# import libraries #############################
library(lubridate)
library(ggplot2)
library(ggpubr)
library(reshape2)
library(GA)
library(parallel)
library(purrr)
source("functions.R")
############################# data reading #############################
filename_gen_1 = "data/202005081411_charts_compare.csv"
# cons_1 is too high
filename_cons_1 = "data/202005081413_charts_compare.csv"
filename_cons_2 = "data/202005081655_charts_compare.csv"
filename_cons_3 = "data/202005081656_charts_compare.csv"
filename_cons_4 = "data/202005081658_charts_compare.csv"
# new:
filename_cons_5 = "data/202103171643_charts_historic.csv"
# gen_5 is too low
filename_gen_5 = "data/202103171649_charts_historic.csv"
filename_cons_6 = "data/202103171657_charts_historic.csv"
# gen_7 is too low
filename_gen_7 = "data/202103171735_charts_historic_generation.csv"
filename_cons_7 = "data/202103171735_charts_historic_cons.csv"
filename_cons_8 = "data/202103171814_charts_historic.csv"
filename_cons_9 = "data/202103171831_charts_historic.csv"
filename_cons_10 = "data/202103171835_charts_historic.csv"
# gen_10 is too low
filename_gen_10 = "data/202103171838_charts_historic.csv"
filename_cons_11 = "data/202103171858_charts_historic.csv"
filename_cons_12 = "data/202103171905_charts_historic.csv"
filename_cons_13 = "data/202103181018_charts_historic.csv"
filename_cons_14 = "data/202103181023_charts_historic.csv"
filename_cons_15 = "data/202103181029_charts_historic.csv"
filename_cons_16 = "data/202103181032_charts_historic.csv"
filename_cons_17 = "data/202103181037_charts_historic.csv"
filename_cons_18 = "data/202103181040_charts_historic.csv"
filenames_list = list(filename_gen_1, filename_cons_2, filename_cons_3, filename_cons_4, filename_cons_5, filename_cons_6, filename_cons_7, filename_cons_8, filename_cons_9, filename_cons_11, filename_cons_12, filename_cons_13, filename_cons_14, filename_cons_15, filename_cons_16, filename_cons_17, filename_cons_18)
df = lapply(X = filenames_list, FUN = import_one_user)
df_month_1 = select_month(df, m=7)
df_month_1 = eliminate_outliers(df_month_1)
df_month_1 = reducing_consumption_fake(df_month_1)
p = plot_initial(df_month_1)
df_month_1 = df_month_1[1:24,]
df_gen = data.frame("gen_1" = df_month_1[, "gen_1"])
df_cons = df_month_1[, grep(pattern = "cons", x = colnames(df_month_1))]
# changing NAs to 0
df_gen[is.na(df_gen)] = 0
df_cons[is.na(df_cons)] = 0
# should always use summer months to calculate the community max
n_community_max = calculate_n_community_max(generation = df_gen$gen_1, df_cons, time = df_month_1$time)
# n_community_max = 6
global_investment = max(df[[1]]$energy, na.rm = T)*1100
#######################################################################################
# generating fake info here: (should ask Eloi for new data)
df_cons = cbind(df_cons, df_cons)
colnames(df_cons)[17:32] = paste0(rep("cons_", 16),17:32)
n_binary_rep = log(ncol(df_cons), base=2)
# TODO: should change this
individual_investment = sapply(df_cons, max, na.rm = TRUE)*1100
# checking:
# sum(sapply(df_cons, max, na.rm = TRUE)*1100) > global_investment
# TODO:
# why the first run has this error? is it still appearing?
# Error in gareal_lsSelection_Rcpp(object) :
#   Too few positive probabilities!
tic = Sys.time()
# TODO: change this
plot_optimization1_vs_optimization2(optimal_combination_using_2_GAs)
best_combination = select_best_combinations_betas(optimal_combination_using_2_GAs)
best_combination
df_gen
sunny_hours_index = which(df_gen != 0)
sunny_hours_index
df_cons
df_cons_day = df_cons[, !is.na(best_combination$payback)]
df_gen_assigned = calculate_gen_assigned_betas(df_gen_day = df_gen_day, matrix_coefficients = best_combination$optimum_coefficients)
df_gen_day = df_gen[sunny_hours_index,]
df_gen_day
df_gen_assigned = calculate_gen_assigned_betas(df_gen_day = df_gen_day, matrix_coefficients = best_combination$optimum_coefficients)
df_gen_assigned
df_gen_assigned_selected
df_gen_assigned_selected_users = calculate_gen_assigned_betas(df_gen_day = df_gen_day, matrix_coefficients = best_combination$optimum_coefficients)
plot_solar_consumption_daily_mean(df_gen = df_gen, df_gen_assigned = df_gen_assigned_selected_users, time = df_month_1$time)
plot_disaggregated_daily_mean_per_user(df_gen_assigned = df_gen_assigned, df_cons_selected = df_cons_selected_users_day, time = df_month_1[, "time"])
df_cons_selected_users_day = df_cons[,best_combination$optimum_coefficients != 0]
df_cons[,best_combination$optimum_coefficients != 0]
df_cons_day
plot_disaggregated_daily_mean_per_user(df_gen_assigned = df_gen_assigned, df_cons_selected = df_cons_selected_users_day, time = df_month_1[, "time"])
df_cons_selected_users
df_cons_selected_users = df_cons[, !is.na(best_combination$payback)]
df_cons_selected_users
df_cons_selected_users_day = df_cons_selected_users[sunny_hours_index,]
plot_solar_consumption_daily_mean(df_gen = df_gen, df_gen_assigned = df_gen_assigned_selected_users, time = df_month_1$time)
plot_solar_consumption_daily_mean_betas(df_gen = df_gen, df_gen_assigned = df_gen_assigned_selected_users, time = df_month_1$time)
plot_solar_consumption_daily_mean_betas <- function(df_gen, df_gen_assigned, df_cons_selected, time){
m = unique(month(time))
df_solar_consumption = calculate_solar_consumption(df_gen_assigned, df_cons_selected)
df_gen$hour = hour(time)
df_solar_consumption$hour = sunny_hours_index
df_gen_mean = aggregate(x = df_gen, by = list(df_gen$hour), FUN = mean)
df_solar_consumption_mean = aggregate(x = df_solar_consumption, by = list(df_solar_consumption$hour), FUN = mean)
df_plot_solar_consumption_mean <- melt(data = df_solar_consumption_mean[, -grep(pattern = "Group.1", x = colnames(df_solar_consumption_mean))], variable.name = "series", id.vars = "hour")
p <- ggplot() +
geom_line(aes(x = df_gen_mean[, "hour"], y = df_gen_mean[, "gen_1"])) +
geom_area(aes(x = df_plot_solar_consumption_mean[, "hour"], y = df_plot_solar_consumption_mean[, "value"], fill = df_plot_solar_consumption_mean[,"series"]), alpha = 0.5) +
labs(x = "Time [h]", y = "PV generation [kWh]", "title" = paste0("PV assignation for month ",m), fill = "User")
return(p)
}
plot_solar_consumption_daily_mean_betas <- function(df_gen, df_gen_assigned, df_cons_selected_users, time){
m = unique(month(time))
df_solar_consumption = calculate_solar_consumption(df_gen_assigned, df_cons_selected_users)
df_gen$hour = hour(time)
df_solar_consumption$hour = sunny_hours_index
df_gen_mean = aggregate(x = df_gen, by = list(df_gen$hour), FUN = mean)
df_solar_consumption_mean = aggregate(x = df_solar_consumption, by = list(df_solar_consumption$hour), FUN = mean)
df_plot_solar_consumption_mean <- melt(data = df_solar_consumption_mean[, -grep(pattern = "Group.1", x = colnames(df_solar_consumption_mean))], variable.name = "series", id.vars = "hour")
p <- ggplot() +
geom_line(aes(x = df_gen_mean[, "hour"], y = df_gen_mean[, "gen_1"])) +
geom_area(aes(x = df_plot_solar_consumption_mean[, "hour"], y = df_plot_solar_consumption_mean[, "value"], fill = df_plot_solar_consumption_mean[,"series"]), alpha = 0.5) +
labs(x = "Time [h]", y = "PV generation [kWh]", "title" = paste0("PV assignation for month ",m), fill = "User")
return(p)
}
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
