payback_ideal = min(calculate_payback_betas(df_cons[df_local_time$sunny, combination_selected==1], df_gen[df_local_time$sunny,], individual_investment_selected, matrix_coefficients = pre_matrix_coefficients))/2
payback_ideal
payback_ideal = min(calculate_payback_betas(df_cons[df_local_time$sunny, combination_selected==1], df_gen[df_local_time$sunny,], individual_investment_selected, matrix_coefficients = pre_matrix_coefficients))/2
optim_results <- ga(type = "real-valued", fitness = fitness_2_betas,
lower = array(0, dim = dim), upper = array(1, dim = dim),
df_gen_day = df_gen_sunny, df_cons_selected_day = df_cons_selected, combination = combination_selected,
individual_investment = individual_investment_selected,
weight_surplus = 0.1, payback_ideal = 0,
# suggestions = as.vector(pre_matrix_coefficients),
popSize = 100, maxiter = 1000) # run = 1000
coefficients_optimum <- optim_results@solution[1, ]
payback_ideal
optim_results <- ga(type = "real-valued", fitness = fitness_2_betas,
lower = array(0, dim = dim), upper = array(1, dim = dim),
df_gen_day = df_gen_sunny, df_cons_selected_day = df_cons_selected, combination = combination_selected,
individual_investment = individual_investment_selected,
weight_surplus = 0.1, payback_ideal = payback_ideal,
# suggestions = as.vector(pre_matrix_coefficients),
popSize = 100, maxiter = 1000) # run = 1000
coefficients_optimum <- optim_results@solution[1, ]
coefficients_optimum = matrix(data = coefficients_optimum, ncol = n_community, nrow = n_sunny_hours, byrow = T)
matrix_coefficients_optimum_0.1_payback_payback_ideal = coefficients_optimum/rowSums(coefficients_optimum)
print_scores_matrix(matrix_coefficients_optimum = matrix_coefficients_optimum_0.1_payback_0, weight_surplus = 0.1)
print_scores_matrix(matrix_coefficients_optimum = matrix_coefficients_optimum_0.1_payback_ideal, weight_surplus = 0.1)
print_scores_matrix(matrix_coefficients_optimum = matrix_coefficients_optimum_0.1_payback_payback_ideal, weight_surplus = 0.1)
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
payback_ideal
print_scores_matrix = function(matrix_coefficients_optimum, weight_surplus, payback_ideal){
payback_years = calculate_payback_betas(df_cons[df_local_time$sunny, combination_selected==1], df_gen[df_local_time$sunny,], individual_investment_selected, matrix_coefficients = matrix_coefficients_optimum)
surplus = colSums(calculate_surplus_hourly_individual_betas(matrix_coefficients_optimum, df_gen[df_local_time$sunny,], df_cons[df_local_time$sunny, combination_selected==1]))
cost_payback = sum(exp(payback_years - payback_ideal))
cost_surplus = sum(surplus)
score = weight_surplus * cost_surplus + (1-weight_surplus) * cost_payback
print("payback years")
print(payback_years)
print("cost payback")
print(cost_payback)
print("surplus")
print(surplus)
print("cost surplus")
print(cost_surplus)
print("score")
print(score)
}
payback_ideal
print_scores_matrix(matrix_coefficients_optimum = matrix_coefficients_optimum_0.1_payback_payback_ideal, weight_surplus = 0.1, payback_ideal = payback_ideal)
print_scores_matrix(matrix_coefficients_optimum = matrix_coefficients_optimum_0.1_payback_payback_ideal, weight_surplus = 0.1, payback_ideal = 0)
print_scores_matrix(matrix_coefficients_optimum = matrix_coefficients_optimum_0.1_payback_payback_ideal, weight_surplus = 0.1, payback_ideal = payback_ideal)
print_scores_matrix(matrix_coefficients_optimum = matrix_coefficients_optimum_0.1_payback_0, weight_surplus = 0.1, payback_ideal = 0)
print_scores_matrix = function(matrix_coefficients_optimum, weight_surplus, payback_ideal){
payback_years = calculate_payback_betas(df_cons[df_local_time$sunny, combination_selected==1], df_gen[df_local_time$sunny,], individual_investment_selected, matrix_coefficients = matrix_coefficients_optimum)
surplus = colSums(calculate_surplus_hourly_individual_betas(matrix_coefficients_optimum, df_gen[df_local_time$sunny,], df_cons[df_local_time$sunny, combination_selected==1]))
cost_payback = sum(exp(payback_years - payback_ideal))
cost_surplus = sum(surplus)
score = weight_surplus * cost_surplus + (1-weight_surplus) * cost_payback
print("payback years")
print(payback_years)
print("cost payback")
print(cost_payback)
print("surplus")
print(surplus)
print("cost surplus")
print(cost_surplus)
print("score")
print(score)
print(payback_years - payback_ideal)
}
print_scores_matrix(matrix_coefficients_optimum = matrix_coefficients_optimum_0.1_payback_0, weight_surplus = 0.1, payback_ideal = 0)
nrow(pre_optimal_combinations)
# i = nrow(pre_optimal_combinations) - 3
i = nrow(pre_optimal_combinations) / 3
i
# i = nrow(pre_optimal_combinations) - 3
i = round(nrow(pre_optimal_combinations) / 3)
i
combination_selected = pre_optimal_combinations[i, ]
combination_selected
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
plot_initial(df)
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
individual_investment_max
individual_investment
# TODO: should change this
individual_investment = sapply(df_cons, max, na.rm = TRUE)*1100
individual_investment_max = individual_investment[combination_selected==1]
individual_investment_max
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
individual_investment_selected = calculate_individual_investment(combination_selected, global_investment, individual_investment_max)
individual_investment_selected
individual_investment_selected
# checking:
pre_surplus_ = calculate_surplus_hourly_community(combination = combination_selected, df_gen = df_gen_sunny, df_cons = df_cons_sunny)
pre_surplus_
pre_surplus_2 = sum(calculate_surplus_hourly_community(combination = combination_selected, df_gen = df_gen_sunny, df_cons = df_cons_sunny))
pre_surplus_2
# i = nrow(pre_optimal_combinations) - 3
i = round(nrow(pre_optimal_combinations) / 4)
combination_selected = pre_optimal_combinations[i, ]
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
pre_optimal_combinations
pre_surplus
optimal_combination_using_2_GAs$pre_surplus
optimal_combination_using_2_GAs$pre_surplus[optimal_combination_using_2_GAs$pre_surplus != 0]
head(optimal_combination_using_2_GAs$pre_surplus[optimal_combination_using_2_GAs$pre_surplus != 0])
head(optimal_combination_using_2_GAs$pre_surplus[optimal_combination_using_2_GAs$pre_surplus 113.2])
head(optimal_combination_using_2_GAs$pre_surplus[optimal_combination_using_2_GAs$pre_surplus == 113.2])
head(optimal_combination_using_2_GAs$pre_surplus[optimal_combination_using_2_GAs$pre_surplus != 0])
head(optimal_combination_using_2_GAs$new_optimum_coefficients)
head(optimal_combination_using_2_GAs$vector_i)
head(optimal_combination_using_2_GAs$pre_surplus[optimal_combination_using_2_GAs$pre_surplus != 0])
head(optimal_combination_using_2_GAs$vector_i)
head(optimal_combination_using_2_GAs$vector_i[optimal_combination_using_2_GAs$pre_surplus != 0])
i = 22
combination_selected = pre_optimal_combinations[i, ]
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
plot_initial(df)
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
individual_investment_selected = calculate_individual_investment(combination_selected, global_investment, individual_investment_max)
individual_investment_selected
# checking:
pre_surplus_ = calculate_surplus_hourly_community(combination = combination_selected, df_gen = df_gen_sunny, df_cons = df_cons_sunny)
pre_surplus_
pre_surplus_2 = sum(calculate_surplus_hourly_community(combination = combination_selected, df_gen = df_gen_sunny, df_cons = df_cons_sunny))
pre_surplus_2
tail(optimal_combination_using_2_GAs$vector_i[optimal_combination_using_2_GAs$pre_surplus != 0])
optimal_combination_using_2_GAs$vector_i[optimal_combination_using_2_GAs$pre_surplus != 0]
tail(optimal_combination_using_2_GAs$vector_i[optimal_combination_using_2_GAs$pre_surplus != 0], 100)
tail(optimal_combination_using_2_GAs$vector_i[optimal_combination_using_2_GAs$pre_surplus != 0], 250)
tail(optimal_combination_using_2_GAs$vector_i[optimal_combination_using_2_GAs$pre_surplus != 0], 500)
tail(optimal_combination_using_2_GAs$vector_i[optimal_combination_using_2_GAs$pre_surplus != 0], 1000)
optimal_combination_using_2_GAs$vector_i[8122,optimal_combination_using_2_GAs$pre_surplus != 0]
optimal_combination_using_2_GAs[8122,optimal_combination_using_2_GAs$pre_surplus != 0]
optimal_combination_using_2_GAs[8122,]
optimal_combination_using_2_GAs$pre_surplus[8122]
optimal_combination_using_2_GAs$pre_surplus[379]
optimal_combination_using_2_GAs$new_optimum_coefficients[379]
optimal_combination_using_2_GAs$vector_i[379]
i = 897
combination_selected = pre_optimal_combinations[i, ]
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
plot_initial(df)
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
individual_investment_selected = calculate_individual_investment(combination_selected, global_investment, individual_investment_max)
# checking:
pre_surplus_ = calculate_surplus_hourly_community(combination = combination_selected, df_gen = df_gen_sunny, df_cons = df_cons_sunny)
pre_surplus_2 = sum(calculate_surplus_hourly_community(combination = combination_selected, df_gen = df_gen_sunny, df_cons = df_cons_sunny))
pre_surplus_2
i = 379
combination_selected = pre_optimal_combinations[i, ]
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
plot_initial(df)
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
individual_investment_selected = calculate_individual_investment(combination_selected, global_investment, individual_investment_max)
# checking:
pre_surplus_ = calculate_surplus_hourly_community(combination = combination_selected, df_gen = df_gen_sunny, df_cons = df_cons_sunny)
pre_surplus_2 = sum(calculate_surplus_hourly_community(combination = combination_selected, df_gen = df_gen_sunny, df_cons = df_cons_sunny))
pre_surplus_2
# TODO: separate the combinations according to the number n_community_per_combination
n_community_per_combination_order = order(rowSums(pre_optimal_combinations))
n_community_per_combination_order
n_community_vector
hourly_surplus = apply(X = pre_optimal_combinations, MARGIN = 1, FUN = calculate_surplus_hourly_community, df_gen = df_gen, df_cons = df_cons)
hourly_surplus
# pre_surplus = as.numeric(lapply(X = hourly_surplus, FUN = sum))
pre_surplus = colSums(hourly_surplus)
df_gen
df_cons
df_gen_sunny
hourly_surplus = apply(X = pre_optimal_combinations, MARGIN = 1, FUN = calculate_surplus_hourly_community, df_gen = df_gen_sunny, df_cons = df_cons_sunny)
hourly_surplus
# pre_surplus = as.numeric(lapply(X = hourly_surplus, FUN = sum))
pre_surplus = colSums(hourly_surplus)
pre_surplus
hourly_surplus
# pre_surplus = as.numeric(lapply(X = hourly_surplus, FUN = sum))
hourly_surplus = apply(X = pre_optimal_combinations, MARGIN = 1, FUN = calculate_surplus_hourly_community, df_gen = df_gen_sunny, df_cons = df_cons_sunny)
pre_surplus = colSums(hourly_surplus)
pre_surplus
nrow(pre_surplus)
length(pre_surplus)
length(n_community_vector)
pre_optimal_combinations[1, ]
pre_surplus_2 = sum(calculate_surplus_hourly_community(combination = pre_optimal_combinations[1, ], df_gen = df_gen_sunny, df_cons = df_cons_sunny))
hourly_surplus = apply(X = pre_optimal_combinations[1, ], MARGIN = 1, FUN = calculate_surplus_hourly_community, df_gen = df_gen_sunny, df_cons = df_cons_sunny)
pre_surplus_2 = sum(calculate_surplus_hourly_community(combination = pre_optimal_combinations[1, ], df_gen = df_gen_sunny, df_cons = df_cons_sunny))
hourly_surplus = apply(X = pre_optimal_combinations, MARGIN = 1, FUN = calculate_surplus_hourly_community, df_gen = df_gen_sunny, df_cons = df_cons_sunny)
pre_surplus = colSums(hourly_surplus)[1]
pre_surplus_2
pre_surplus
pre_surplus_2 = sum(calculate_surplus_hourly_community(combination = pre_optimal_combinations[2, ], df_gen = df_gen_sunny, df_cons = df_cons_sunny))
hourly_surplus = apply(X = pre_optimal_combinations, MARGIN = 1, FUN = calculate_surplus_hourly_community, df_gen = df_gen_sunny, df_cons = df_cons_sunny)
pre_surplus = colSums(hourly_surplus)[2]
pre_surplus_2
pre_surplus
pre_optimal_combinations[i]
hourly_surplus = apply(X = pre_optimal_combinations, MARGIN = 1, FUN = calculate_surplus_hourly_community, df_gen = df_gen_sunny, df_cons = df_cons_sunny)
pre_surplus = colSums(hourly_surplus)
pre_surplus
head(pre_surplus)
tail(pre_surplus, 500)
tail(pre_surplus)
length(pre_surplus)
pre_surplus[7270:7280]
pre_surplus[7277]
pre_surplus[7276]
i = 7276
combination_selected = pre_optimal_combinations[i, ]
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
plot_initial(df)
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
individual_investment_selected = calculate_individual_investment(combination_selected, global_investment, individual_investment_max)
tail(pre_surplus)
pre_surplus[7270:7275]
pre_surplus[7274]
i = 7274
combination_selected = pre_optimal_combinations[i, ]
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
plot_initial(df)
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
pre_surplus[pre_surplus<30 & pre_surplus>0]
pre_surplus[pre_surplus<30 & pre_surplus>5]
pre_surplus$X1029
pre_surplus[pre_surplus<10 & pre_surplus>9]
which(pre_surplus<10 & pre_surplus>9)
i = 20
combination_selected = pre_optimal_combinations[i, ]
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
plot_initial(df)
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
pre_surplus[pre_surplus<5 & pre_surplus>4]
which(pre_surplus<5 & pre_surplus>4)
i = 592
combination_selected = pre_optimal_combinations[i, ]
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
plot_initial(df)
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
sum(individual_investment_max)
global_investment
pre_surplus[pre_surplus<2 & pre_surplus>1]
which(pre_surplus<2 & pre_surplus>1)
i = 26
combination_selected = pre_optimal_combinations[i, ]
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
plot_initial(df)
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
i = 189
combination_selected = pre_optimal_combinations[i, ]
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
plot_initial(df)
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
individual_investment_selected = calculate_individual_investment(combination_selected, global_investment, individual_investment_max)
hourly_surplus = apply(X = pre_optimal_combinations, MARGIN = 1, FUN = calculate_surplus_hourly_community, df_gen = df_gen_sunny, df_cons = df_cons_sunny)
pre_surplus = colSums(hourly_surplus)
pre_surplus
pre_surplus_2 = sum(calculate_surplus_hourly_community(combination = pre_optimal_combinations[i, ], df_gen = df_gen_sunny, df_cons = df_cons_sunny))
pre_surplus_2
pre_surplus[i]
which(pre_surplus<2 & pre_surplus>1)
i = 7141
combination_selected = pre_optimal_combinations[i, ]
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
plot_initial(df)
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
individual_investment_selected = calculate_individual_investment(combination_selected, global_investment, individual_investment_max)
pre_surplus_2 = sum(calculate_surplus_hourly_community(combination = pre_optimal_combinations[i, ], df_gen = df_gen_sunny, df_cons = df_cons_sunny))
pre_surplus[i]
pre_surplus_2
pre_surplus[pre_surplus<10 & pre_surplus>9]
which(pre_surplus<10 & pre_surplus>9)
i = 7216
combination_selected = pre_optimal_combinations[i, ]
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
plot_initial(df)
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
i = 6915
combination_selected = pre_optimal_combinations[i, ]
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
plot_initial(df)
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
individual_investment_selected = calculate_individual_investment(combination_selected, global_investment, individual_investment_max)
pre_surplus_2 = sum(calculate_surplus_hourly_community(combination = pre_optimal_combinations[i, ], df_gen = df_gen_sunny, df_cons = df_cons_sunny))
pre_surplus[i]
pre_surplus_2
pre_surplus[pre_surplus<5 & pre_surplus>4]
which(pre_surplus<5 & pre_surplus>4)
i = 7083
combination_selected = pre_optimal_combinations[i, ]
df_cons_selected = df_cons_sunny[,combination_selected==1]
individual_investment_max = individual_investment[combination_selected==1]
df = data.frame("time" = df_local_time$time[df_local_time$sunny],
"gen" = df_gen_sunny)
df = cbind(df, df_cons_selected)
plot_initial(df)
# TODO: include this in the pre_optimization?
# should satisfy this condition:
print(sum(individual_investment_max) > global_investment)
individual_investment_selected = calculate_individual_investment(combination_selected, global_investment, individual_investment_max)
pre_surplus_2 = sum(calculate_surplus_hourly_community(combination = pre_optimal_combinations[i, ], df_gen = df_gen_sunny, df_cons = df_cons_sunny))
pre_surplus[i]
pre_surplus_2
combination_selected
# checking:
pre_surplus_ = calculate_surplus_hourly_community(combination = combination_selected, df_gen = df_gen_sunny, df_cons = df_cons_sunny)
pre_surplus_2 = sum(calculate_surplus_hourly_community(combination = combination_selected, df_gen = df_gen_sunny, df_cons = df_cons_sunny))
pre_surplus_2
pre_surplus_
pre_matrix_coefficients = calculate_matrix_coefficients(df_gen_sunny, df_cons_selected)
pre_matrix_coefficients
# TODO: this should be inside the calculate_matrix_coefficients
pre_matrix_coefficients = matrix(pre_matrix_coefficients, nrow = n_sunny_hours, ncol = n_community)
pre_surplus = calculate_surplus_hourly_individual_betas(pre_matrix_coefficients, df_gen_sunny, df_cons_selected)
pre_payback = calculate_payback_betas(df_cons_selected, df_gen_sunny, individual_investment_selected, pre_matrix_coefficients)
pre_surplus
pre_payback
# TODO: this should be added all in a function
# checking:
df_gen_assigned = calculate_gen_assigned_betas(df_gen_day = df_gen_sunny, matrix_coefficients = pre_matrix_coefficients)
plot_solar_consumption_daily_mean_betas(df_gen = df_gen, df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons_selected, df_local_time)
plot_disaggregated_daily_mean_per_user_betas(df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons[, combination_selected==1], df_local_time)
plot_disaggregated_daily_mean_community_betas(df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons[, combination_selected==1], df_local_time)
plot_economic_comparison_betas(df_gen = df_gen, df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons[, combination_selected==1], matrix_coefficients = pre_matrix_coefficients, df_local_time = df_local_time)
n_community = ncol(df_gen_assigned)
n_community
matrix_coefficients_non_optimum = matrix_coefficients
matrix_coefficients_non_optimum[,] = 1/n_community
# TODO: this should be added all in a function
# checking:
df_gen_assigned = calculate_gen_assigned_betas(df_gen_day = df_gen_sunny, matrix_coefficients = pre_matrix_coefficients)
plot_solar_consumption_daily_mean_betas(df_gen = df_gen, df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons_selected, df_local_time)
plot_disaggregated_daily_mean_per_user_betas(df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons[, combination_selected==1], df_local_time)
plot_disaggregated_daily_mean_community_betas(df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons[, combination_selected==1], df_local_time)
plot_economic_comparison_betas(df_gen = df_gen, df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons[, combination_selected==1], matrix_coefficients = pre_matrix_coefficients, df_local_time = df_local_time)
matrix_coefficients_non_optimum
# TODO: this should be added all in a function
# checking:
df_gen_assigned = calculate_gen_assigned_betas(df_gen_day = df_gen_sunny, matrix_coefficients = matrix_coefficients_non_optimum)
plot_solar_consumption_daily_mean_betas(df_gen = df_gen, df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons_selected, df_local_time)
plot_solar_consumption_daily_mean_betas(df_gen = df_gen, df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons_selected, df_local_time)
plot_disaggregated_daily_mean_per_user_betas(df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons[, combination_selected==1], df_local_time)
plot_disaggregated_daily_mean_community_betas(df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons[, combination_selected==1], df_local_time)
plot_economic_comparison_betas(df_gen = df_gen, df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons[, combination_selected==1], matrix_coefficients = pre_matrix_coefficients, df_local_time = df_local_time)
plot_economic_comparison_betas(df_gen = df_gen, df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons[, combination_selected==1], matrix_coefficients = pre_matrix_coefficients, df_local_time = df_local_time)
# TODO: this should be added all in a function
# checking:
df_gen_assigned = calculate_gen_assigned_betas(df_gen_day = df_gen_sunny, matrix_coefficients = pre_matrix_coefficients)
plot_economic_comparison_betas(df_gen = df_gen, df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons[, combination_selected==1], matrix_coefficients = pre_matrix_coefficients, df_local_time = df_local_time)
n_community
n_community = as.numeric(n_community_vector[i])
n_community
n_sunny_hours = nrow(df_cons_selected)
dim = calculate_dim(hourly, n_community, n_sunny_hours)
n_sunny_hours
dim
optim_results <- ga(type = "real-valued", fitness = fitness_2_betas,
lower = array(0, dim = dim), upper = array(1, dim = dim),
df_gen_day = df_gen_sunny, df_cons_selected_day = df_cons_selected, combination = combination_selected,
individual_investment = individual_investment_selected,
weight_surplus = 0.1,
# suggestions = as.vector(pre_matrix_coefficients),
popSize = 100, maxiter = 500, run = 500)
optim_results <- ga(type = "real-valued", fitness = fitness_2_betas,
lower = array(0, dim = dim), upper = array(1, dim = dim),
df_gen_day = df_gen_sunny, df_cons_selected_day = df_cons_selected, combination = combination_selected,
individual_investment = individual_investment_selected,
weight_surplus = 0.1, payback_ideal = 0
# suggestions = as.vector(pre_matrix_coefficients),
popSize = 100, maxiter = 500, run = 500)
optim_results <- ga(type = "real-valued", fitness = fitness_2_betas,
lower = array(0, dim = dim), upper = array(1, dim = dim),
df_gen_day = df_gen_sunny, df_cons_selected_day = df_cons_selected, combination = combination_selected,
individual_investment = individual_investment_selected,
weight_surplus = 0.1, payback_ideal = 0,
# suggestions = as.vector(pre_matrix_coefficients),
popSize = 100, maxiter = 500, run = 500)
coefficients_optimum <- optim_results@solution[1, ]
coefficients_optimum = matrix(data = coefficients_optimum, ncol = n_community, nrow = n_sunny_hours, byrow = T)
matrix_coefficients_optimum_0.1 = coefficients_optimum/rowSums(coefficients_optimum)
matrix_coefficients_optimum_0.1
matrix_coefficients_optimum = matrix_coefficients_optimum_0.1
# TODO: this should be added all in a function
# checking:
df_gen_assigned = calculate_gen_assigned_betas(df_gen_day = df_gen_sunny, matrix_coefficients = matrix_coefficients_optimum)
plot_solar_consumption_daily_mean_betas(df_gen = df_gen, df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons_selected, df_local_time)
plot_disaggregated_daily_mean_per_user_betas(df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons[, combination_selected==1], df_local_time)
plot_disaggregated_daily_mean_community_betas(df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons[, combination_selected==1], df_local_time)
plot_economic_comparison_betas(df_gen = df_gen, df_gen_assigned = df_gen_assigned, df_cons_selected_users = df_cons[, combination_selected==1], matrix_coefficients = matrix_coefficients_optimum, df_local_time = df_local_time)
weight_surplus
payback_ideal = 0
weight_surplus = 0.1
payback_years = calculate_payback_betas(df_cons[df_local_time$sunny, combination_selected==1], df_gen[df_local_time$sunny,], individual_investment_selected, matrix_coefficients = matrix_coefficients_non_optimum)
surplus = colSums(calculate_surplus_hourly_individual_betas(matrix_coefficients_non_optimum, df_gen[df_local_time$sunny,], df_cons[df_local_time$sunny, combination_selected==1]))
cost_payback = sum(exp(payback_years - payback_ideal))
cost_surplus = sum(surplus)
score = weight_surplus * cost_surplus + (1-weight_surplus) * cost_payback
print(payback_years)
print(surplus)
print(cost_payback)
print(cost_surplus)
print(score)
pre_matrix_coefficients
pre_surplus_2
pre_surplus_
pre_matrix_coefficients = calculate_matrix_coefficients(df_gen_sunny, df_cons_selected)
# TODO: this should be inside the calculate_matrix_coefficients
pre_matrix_coefficients = matrix(pre_matrix_coefficients, nrow = n_sunny_hours, ncol = n_community)
pre_surplus = calculate_surplus_hourly_individual_betas(pre_matrix_coefficients, df_gen_sunny, df_cons_selected)
pre_payback = calculate_payback_betas(df_cons_selected, df_gen_sunny, individual_investment_selected, pre_matrix_coefficients)
n_community = ncol(df_gen_assigned)
matrix_coefficients_non_optimum = matrix_coefficients
matrix_coefficients_non_optimum[,] = 1/n_community
print_scores_matrix(matrix_coefficients_optimum = matrix_coefficients_optimum_0.1, weight_surplus = 0.1, payback_ideal = 0)
print_scores_matrix(matrix_coefficients_optimum = pre_matrix_coefficient, weight_surplus = 0.1, payback_ideal = 0)
print_scores_matrix(matrix_coefficients_optimum = matrix_coefficients_non_optimum, weight_surplus = 0.1, payback_ideal = 0)
pre_surplus
# checking:
pre_surplus_ = calculate_surplus_hourly_community(combination = combination_selected, df_gen = df_gen_sunny, df_cons = df_cons_sunny)
pre_surplus_2 = sum(calculate_surplus_hourly_community(combination = combination_selected, df_gen = df_gen_sunny, df_cons = df_cons_sunny))
pre_matrix_coefficients = calculate_matrix_coefficients(df_gen_sunny, df_cons_selected)
# TODO: this should be inside the calculate_matrix_coefficients
pre_matrix_coefficients = matrix(pre_matrix_coefficients, nrow = n_sunny_hours, ncol = n_community)
pre_matrix_coefficients
pre_surplus = calculate_surplus_hourly_individual_betas(pre_matrix_coefficients, df_gen_sunny, df_cons_selected)
pre_surplus
sum(pre_surplus)
pre_surplus = calculate_surplus_hourly_individual_betas(pre_matrix_coefficients, df_gen_sunny, df_cons_selected)
pre_surplus
print_scores_matrix(matrix_coefficients_optimum = pre_matrix_coefficient, weight_surplus = 0.1, payback_ideal = 0)
source('~/Documents/projects/EKATE/transactive_energy_EKATE/functions.R')
